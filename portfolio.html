<!doctype html>
	<html lang="en">
	  <head>
	    <meta charset="utf-8">
	    <title>Portfolio</title>
	  </head>
	  <body>
    <a href="index.html">Home</a>
    <a href="portfolio.html">Portfolio</a>
      <a href="aboutme.html">About Me</a>
    <h1>Portfolio</h1>
    <h3>Blown to Bits Reflection </h3>
    <p>Computing will transform society, true or false? Ever since the boom of computers society has been truly everchanging. Computers have made society change for the better and worse. Computers have made communication as simple as a push of a button and have created a source where people can openly share ideas. Ways that computers maybe bad is the fact that nothing you look up or type is safe. The government can view everything you have ever said or done.  This can be good in the fact you know that ever the bad thing is monitored but this also means everything you do is monitored. Nothing can be published with parts hidden because everything that you do on a computer is irreversible unlike in the past where sensitive information could be blocked out and published. This changes society because everyone has to carefully watch their steps and no one is really anonymous anymore.</p>
    <h3>Lightbot Reflection</h3>
    <p>How is Lightbot like a computer? How is Lightbot different than a computer?
A computer is an electronic device that is used for storing and processing data. Lightbot resembles this because you follow a pattern and produce a code which the little robot processes and follows. Both things comprehend human code and produce what it is the human is trying to accomplish. A way that Lightbot is different from an actual computer because it is not as complex. It cannot process the same amount of data a computer can and it only has a minimal amount of actions it can accomplish. Although they are similar in the sense both need to be coded and contain pieces of code and loops they are also different based on the amount of things they are able to do.</p>

     <img src="images/Light bot.PNG" height="800">
     
     <br>
     
     <iframe allowtransparency="true" width="485" height="402" src="//scratch.mit.edu/projects/embed/172449623/?autostart=false" frameborder="0" allowfullscreen></iframe>
	 <br>
	 <h3>Scratch P.1 Conclusion</h3>
	 <p>1. It’s a good idea to write code in small pieces so you don’t make a little mistake in a huge amount of code; basically It saves time.</p>
	 <p>2. In math it is easy to make small mistakes and to have to restart several times on a problem. This is like coding because it’s easy to make such little mistakes that mess up everything in the long run. A way that is is different is that coding is mainly abbreviations and shortcuts while math could be you wrote the wrong number. </p>
	 <p>3. Dual-core computers make you feel like it’s running 10 more programs at once by the speed of it and the fact it is spread out on more than just one core and it improves the overall performance. </p>
	
	<br>
	 <h3>Scratch P.2 Conclusion</h3>
	 <p>1. It is better because if there are numerous sprites that are responding to one message the sprites code might get confused but if there is just a single sprite responding to a code it will know what to do simply.</p>
	 <p>2. An event would be, for example, the broadcast; while the handle would be the Sprite doing the action.</p>
	 <p>3. A. Like how the accelerator pedal's actions are encapsulated under the hood in scratch the buttons actions are encapsulated in the code behind handler; this includes the timer behind the notes. Programmers do not set this timer it is just something that is already encapsulated in order to make things less complex. </p>
	 <p>3. B. I think it would be easier to expose the sound of “note 67” to know how load and high pitch the note is without repeatedly testing out notes to see how they sound. </p>
	       <iframe allowtransparency="true" width="485" height="402" src="//scratch.mit.edu/projects/embed/172963483/?autostart=false" frameborder="0" allowfullscreen></iframe>
	 
	 <br>
	 <h3>Variable Roles</h3>
	 <p>1. The primary advantage of using a fix variable is that it is a fast and easy way to change the program and it’s harder to make mistakes with the set speed.</p>
	 <p>2. When you input money into your bank account you would want to see the amount of money you had in there before to know how much you can withdraw later and see your growth. </p>	
	 <p>3. A. I suspect a scoreboard and an adding machine use an accumulator.</p>
	 <p>3. B. I think a scoreboard has an accumulator because its job is to keep track of what is clicked how many times and when it is turned on it resets. </p>
	 <p>4. An accumulator keeps track of the given points while an aggregation is the sum of all the points.</p>
	       <iframe allowtransparency="true" width="485" height="402" src="//scratch.mit.edu/projects/embed/173640734/?autostart=false" frameborder="0" allowfullscreen></iframe>
    <br>
	
	 <a href="https://scratch.mit.edu/projects/173799830/#editor">https://scratch.mit.edu/projects/173799830/#editor</a>
	  <br>
	  <h3>Variable Roles Part 2</h3>
	  <p>1. A stepper is a predetermined sequence of values and executes one set of instructions and a time. A walker is the element that enables the program to move on collectively one step at a time. A best so far is a record holder.</p>
	  <p>2. When playing the match game on quizlet, Quizlet saves your lowest time, from a timer, to give you your best score. This a best so far is because it saves your best time on each list.</p>	
 <br>
     <h3>Spooky's Maze - Partner Game </h3>
     <video controls>
     <source src="files/HaleysVideo.mp4" type="video/mp4">
     This browser does not support the video tag
     </video>
     
   <br>
   	 <a href="https://scratch.mit.edu/projects/174862003/#player">https://scratch.mit.edu/projects/174862003/#player</a>
   <br>
   <h3>Spooky's Maze Written Response</h3>
   <p>	The game that my partner Austin Hanson and I have created is a series of Halloween mazes that you have to complete one by one. The mazes themself tells a story; your character starts off as a flame that transfers onto a candle, the candle then has to make its way to a pumpkin, and finally the lit up pumpkin has to find its way back to the headless horseman. The commands are the up, down, left, and right arrows. You use these in order to maneuver through the maze; the trick is you can not touch the sides of the maze. If you end up touching one of the sides that character gets sent back to the original starting point of the maze. In the video it shows the end maze and what happens once you finish the maze; the horse man is no longer headless and you win. </p>
	
	
	
	<br>
	<h3> 1.2.2 Conclusion Questions</h3>
	<p>1. App inventor and scratch are alike due to the ability to be able to run them at the sametime you are designing them. Backgrounds and sprites are not shown up in the Scratch program’s scripts. The background and sprites have their own separate area to code them; they have separate scripts. </p>
	<p>2. Being able to program their own devices would change society because they would be able to design what ever application they would need at a specific time. This would cause a mass growth in the similarity of applications because more and more people would work off each other to build great things.</p>

	<br>

	<h3>1.2.3 Conclusion Questions</h3>
	<p>1. App inventor is different then scratch because scratch is only designed to handle functions a computer can do while app inventor is able to include functions only and mobile device has. </p>
	<p>2. Designing a mobile app is different from a laptop application because there are some features that you can on a mobile app that you cannot have on computer. An example of this would be orientation feature. You can turn a tablet or phone on its side but you cannot turn a laptop and expect the screen to coincide. </p>

 <br>
<h3> Interactive Fiction </h3>
 <a href="https://repl.it/MnOC/6">https://repl.it/MnOC/6</a>
 <br>
 <a href=" https://drive.google.com/file/d/0B2PIUreMnrEkaDZTS3laUE44TVk/view?usp=sharing"> https://drive.google.com/file/d/0B2PIUreMnrEkaDZTS3laUE44TVk/view?usp=sharing</a>

<br>
<h3>1.3.3 Conclusion Questions</h3>
<p>1. The relationship between an If, Elif, and Else is that when a program runs it first looks to see in the if statement is true, if it is true then it runs whatever is implemented, or false. If the statement is false of the if then it moves on to see Elif statement true, if it is true then it runs whatever is implemented, or false. If both the if and the elif are false then it runs the else statement. </p>
<p>2. Some boolean phrases that we have learned in this course so far are: and, or, and not. Another boolean phrase that I’ve found on the internet is “” and this causes that engine to only return results that contain the exact words in the quotes.</p>	
<p>3. All three of the students are technically correct. Although the code runs basically instantaneously after the input is set it would just take more time for the user to understand. Also, if eventually you have to go back and change your code you would need to remember to change it in multiple places in order to have the same format. Lastly it is going to be stated no matter what and there is no point in taking the time to have each function output state the same thing. </p>	
	
<br>
<h3>1.3.8 Conclusion Questions</h3>	
<p>1. Insertion is the fastest sorting algorithm when a list is neatly sorted. </p>
<p>2. The merge sort takes about the same amount of time to sort throughout each of the various data sets.</p>
<p>3. You would need at least 8 guesses to guarantee you find out their birthday. </p>
<p>4. An unsorted list cannot be searched with binary search because if you have already guessed a number and passed it you would have to take the time to go all the way through again at random. </p>
<p>5. Google keeps its inventory of webpage content sorted for efficiency and you know this because it only takes seconds to find what you are looking for. </p>

<br>	
<h3>1.3.10 Game Theory</h3>
<p>1. Even in cheesy kids games like the game “rock, paper, scissors” you have to decide a strategy without knowing what the other person is going to play; and later pick up patterns that they follow. Computer simulations have changed social sciences by helping planners of war understand certain outcomes from reactions. The uses of computer simulations are endless in finding specific outcomes .</p>
<p>2. Abstraction: a technique for arranging complexity of computer systems. Abstraction is useful in coding because entire sections of code don't have to type out the when a function that is already defined.</p>	
<p>3. The abstractions that are throughout the codes help organize and maintain the complexity of code. It creates a function with a specific value, and helps manage time by not forcing people to retype out the function multiple times if used again. Creating an abstraction helps reduce the mess and chances of mistakes that could be created from having to type it out multiple times.</p>	
	
<br>
<h3>1.4.2 Conclusion Questions</h3>
<p>1. An Absolute Filename can specify all the directory names of an entire pathway starting from the root; while the relative filename can only specify from the current working directory. </p>
<p>2. An object is a specific instance of a class with a specific set of values for its own attributes that is able to execute any methods defined in its class.</p>	  
<p>3. Methods are instructions executed for a particular object and properties are the settings of an object on a computer.</p>
<p>4.  When you call upon a method on an object it creates instructions for that particular object.</p>

<br>
<h3>1.4.3 Concusion Questions</h3>
<p>1. When a digital image is altered the values array of the image is changed.</p>
<p>2. Digital cameras and light sensitive cameras are different because a light sensitive camera takes an image by taking in light and putting the picture onto light sensitive film, while a digital camera performs by taking in the light and a light sensor takes the light waves and processes them to produce an image.</p>	  
<p>3a. Because the majority of the time it is the background and if there is a little change most people wouldn’t notice. </p>
<p>3b.  Because the data will become compressed </p>
<p>3c. The image would become slightly off; probable barely noticable.</p>
<p>4. It would look for RGB values that are similar to each other within a certain boundary and then compare them to the different values within that boundary. </p>
	  
	  
	  
	  
	  
	  
	  
	  </body>
	 
	  
	</html>
